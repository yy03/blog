(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{463:function(t,a,s){"use strict";s.r(a);var e=s(1),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_1-mysql中的存储引擎"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql中的存储引擎"}},[t._v("#")]),t._v(" 1. MySQL中的存储引擎")]),t._v(" "),s("p",[t._v("在mysql中用的最多的存储引擎有：")]),t._v(" "),s("ul",[s("li",[t._v("InnoDB：支持事务，默认存储引擎")]),t._v(" "),s("li",[t._v("Myisam：不支持事务，v 5.5之前默认存储引擎")]),t._v(" "),s("li",[t._v("Memory：不支持事务")])]),t._v(" "),s("h1",{attrs:{id:"_2-事务的介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务的介绍"}},[t._v("#")]),t._v(" 2. 事务的介绍")]),t._v(" "),s("p",[t._v("事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。如果单元中某条sql语句执行失败或者产生错误，整个单元将会回滚。所有收到影响的数据将返回到事务开始之前的状态；如果单元中的所有sql语句均执行成功，则事务顺利执行。")]),t._v(" "),s("p",[t._v("事务的ACID特性：")]),t._v(" "),s("ul",[s("li",[t._v("原子性 Atomicity：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。")]),t._v(" "),s("li",[t._v("一致性 Consistency：事务必须使数据库从一个一致性状态变换到另一个一致性状态。")]),t._v(" "),s("li",[t._v("隔离性 Isolation：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。（需要适用到隔离级别）")]),t._v(" "),s("li",[t._v("持久性 Durability：持久性是指一个事务一旦被提交，它对数据库中的数据改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。")])]),t._v(" "),s("h1",{attrs:{id:"_3-事务的创建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务的创建"}},[t._v("#")]),t._v(" 3. 事务的创建")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("隐式创建：事务没有明显的开启和结束的标记。比如insert、update、delete语句")])]),t._v(" "),s("li",[s("p",[t._v("显式创建：事务具有明显的开启和结束的标记。")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("START")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TRANSACTION")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" account "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" balance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" account"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("username "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'zhangsan'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" account "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" account"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("balance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1500")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" account"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("username "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'lisi'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("START")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TRANSACTION")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" account "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" balance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" account"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("username "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'zhangsan'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" account "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" account"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("balance "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" account"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("username "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'lisi'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ROLLBACK")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#回滚，即不执行")]),t._v("\n")])])])])]),t._v(" "),s("h1",{attrs:{id:"_4-事务并发问题的介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-事务并发问题的介绍"}},[t._v("#")]),t._v(" 4. 事务并发问题的介绍")]),t._v(" "),s("p",[t._v("对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：")]),t._v(" "),s("ul",[s("li",[t._v("脏读： "),s("strong",[t._v("（针对未提交数据）"),s("strong",[t._v("如果一个事务中对数据进行了更新，但")]),t._v("事务还没有提交")]),t._v("，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据。")]),t._v(" "),s("li",[t._v("幻读："),s("strong",[t._v("（针对其他提交前后，读取数据条数的对比）")]),t._v(" 幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的，所以，Read Uncommitted同样无法避免幻读的问题。")]),t._v(" "),s("li",[t._v("不可重复读：**（针对其他提交前后，读取数据本身的对比）**不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，Read Uncommitted也无法避免不可重复读取的问题。")])]),t._v(" "),s("h1",{attrs:{id:"_5-事务的隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-事务的隔离级别"}},[t._v("#")]),t._v(" 5. 事务的隔离级别")]),t._v(" "),s("p",[t._v("数据库的隔离性就是去解决事务并发带来的问题。事务的四个隔离级别：Read Uncommitted, Read commited, Repeatable read, Serializable，MySQL中默认使用Repeatable read")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Read Uncommitted：读未提交数据，最低的隔离级别，Read Uncommitted最直接的效果就是一个事务可以读取另一个事务并未提交的更新结果。脏读、幻读、不可重复读的问题都会出现。")])]),t._v(" "),s("li",[s("p",[t._v("Read Committed：读已提交数据，通常是大部分数据库采用的默认隔离级别，它在Read Uncommitted隔离级别基础上所做的限定更进一步， 在该隔离级别下，一个事务的更新操作结果只有在该事务提交之后，另一个事务才可能读取到同一笔数据更新后的结果。 所以，Read Committed可以避免Read Uncommitted隔离级别下存在的脏读问题， 但无法避免不可重复读取和幻读的问题。")])]),t._v(" "),s("li",[s("p",[t._v("Repeatable Read：可重复读，Repeatable Read隔离级别可以保证在整个事务的过程中，对同一笔数据的读取结果是相同的，不管其他事务是否同时在对同一笔数据进行更新，也不管其他事务对同一笔数据的更新提交与否。 Repeatable Read隔离级别避免了脏读和不可重复读取的问题，但无法避免幻读。（mysql默认隔离级别）")])]),t._v(" "),s("li",[s("p",[t._v("Serializable：串行化，最为严格的隔离级别，所有的事务操作都必须依次顺序执行，可以避免其他隔离级别遇到的所有问题，是最为安全的隔离级别， 但同时也是性能最差的隔离级别，因为所有的事务在该隔离级别下都需要依次顺序执行，所以，并发度下降，吞吐量上不去，性能自然就下来了。 因为该隔离级别极大的影响系统性能，所以，很少场景会使用它。通常情况下，我们会使用其他隔离级别加上相应的并发锁的机制来控制对数据的访问，这样既保证了系统性能不会损失太大，也能够一定程度上保证数据的一致性。")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);